package {{.PackageName}}
{{if or .MemberFunctions .FieldDefinitions}}
import (
    "errors"
	"encoding/json"
	"github.com/aws/aws-sdk-go/aws"
	"github.com/aws/aws-sdk-go/service/lambda"
	"github.com/Astenna/Nubes/lib"
){{end}}

type {{if eq .NobjectImplementation ""}} {{.TypeNameOrginalCase}} {{else}} {{.TypeNameLower}} {{end}} struct {
	{{if eq .NobjectImplementation ""}}
		{{range .FieldDefinitions}}
    		{{if .IsReference}} {{.FieldNameUpper}} lib.Reference[{{.FieldType}}] 
    		{{else if .IsReferenceList}} {{.FieldNameUpper}} lib.ReferenceList[{{.FieldType}}] 
			{{else}} {{.FieldNameUpper}} {{.FieldType}} {{end}} 
		{{end}}
	{{else}}
	id string
	{{end}} 
}


{{if .NobjectImplementation}} // ALL THE CODE BELOW IS GENERATED ONLY FOR NOBJECTS TYPES
func ({{$.TypeNameLower}})GetTypeName() string {{.NobjectImplementation}} 


// CONSTRUCTOR

func New{{.TypeNameOrginalCase}}(id string) {{.TypeNameLower}} {
	newInstance := new({{.TypeNameLower}})
	newInstance.id = id
	return *newInstance
} 
 
// GETID

func (s {{$.TypeNameLower}})GetId() string {
	return s.id
}

// GETTERS AND SETTERS

{{range .FieldDefinitions}}
{{if ne .FieldNameUpper "Id"}}
func (s {{$.TypeNameLower}}) Get{{.FieldNameUpper}}() ({{.FieldType}}, error) {
	if s.id == "" {
		return *new({{.FieldType}}), errors.New("id of the type not set, use New{{$.TypeNameOrginalCase}} constructor to create new instance of the type")
	}


	params := lib.HandlerParameters{
		Id: s.GetId(),
		TypeName:  s.GetTypeName(),
		Parameter: lib.GetFieldParam{
			FieldName: "{{.FieldNameUpper}}",
		},
	}
	jsonParam, err := json.Marshal(params)
	if err != nil {
		return *new({{.FieldType}}), err
	}

	out, _err := LambdaClient.Invoke(&lambda.InvokeInput{FunctionName: aws.String("GetField"), Payload: jsonParam})
	if _err != nil {
		return *new({{.FieldType}}), _err
	}

	{{if .IsReference}}
	result := new(lib.Reference[{{.FieldType}}])
	err = json.Unmarshal(out.Payload, result)
	if err != nil {
		return *new({{.FieldType}}), err
	}
	var referenceResult = New{{.FieldTypeUpper}}(result.Id)
	return referenceResult, err
	{{else}}
	result := new({{.FieldType}})
	err = json.Unmarshal(out.Payload, result)
	if err != nil {
		return *new({{.FieldType}}), err
	}
	return *result, err
	{{end}}
} {{end}}
{{if .IsReference}}
func (s {{$.TypeNameLower}}) Get{{.FieldNameUpper}}Id() (string, error) {
	if s.id == "" {
		return "", errors.New("id of the type not set, use New{{$.TypeNameOrginalCase}} constructor to create new instance of the type")
	}

	jsonParam, err := json.Marshal(s.id)
	if err != nil {
		return "", err
	}

	out, _err := LambdaClient.Invoke(&lambda.InvokeInput{FunctionName: aws.String("{{$.TypeNameOrginalCase}}"), Payload: jsonParam})
	if _err != nil {
		return "", _err
	}

	result := new(lib.Reference[{{.FieldType}}])
	err = json.Unmarshal(out.Payload, result)
	if err != nil {
		return "", err
	}

	return result.Id, err
}
{{end}}
{{if eq .IsReadonly false}}
func (s {{$.TypeNameLower}}) Set{{.FieldNameUpper}}(newValue {{if .IsReference}}string{{else}}{{.FieldType}}{{end}}) error {
	if s.id == "" {
		return errors.New("id of the type not set, use New{{$.TypeNameOrginalCase}} constructor to create new instance of the type")
	}
	
	params := lib.HandlerParameters{
		Id: s.GetId(),
		TypeName:  s.GetTypeName(),
		Parameter: lib.SetFieldParam{
			FieldName: "{{.FieldNameUpper}}",
			Value: newValue,
		},
	}
	jsonParam, err := json.Marshal(params)
	if err != nil {
		return err
	}

	_, _err := LambdaClient.Invoke(&lambda.InvokeInput{FunctionName: aws.String("SetField"), Payload: jsonParam})
	return _err
} 
{{end}}{{end}}


// (STATE-CHANGING) METHODS

{{range .MemberFunctions}}
func ({{.ReceiverName}} {{$.TypeNameLower}}) {{.FuncName}}({{if .InputParamType}}input {{.InputParamType}}{{end}}) {{if .OptionalReturnType}} ({{.OptionalReturnType}}, error) {{else}} error {{end}} {
	{{if.ReceiverName}} if {{.ReceiverName}}.id == "" {
		return {{if .OptionalReturnType}} *new({{.OptionalReturnType}}), {{end}} errors.New("id of the type not set, use New{{$.TypeNameOrginalCase}} constructor to create new instance of the type")
	}{{end}}
	
	{{if or .ReceiverName .InputParamType}}params := new(lib.HandlerParameters) {{end}}
    {{if .ReceiverName}} params.Id = {{.ReceiverName}}.id {{end}}
    {{if .InputParamType}} params.Parameter = input {{end}}

	{{if or .ReceiverName .InputParamType}} jsonParam, err := json.Marshal(params)
	if err != nil {
		return {{if .OptionalReturnType}} *new({{.OptionalReturnType}}), {{end}} err
	} {{end}}

	{{if .OptionalReturnType}}out{{else}}_{{end}}, _err := LambdaClient.Invoke(&lambda.InvokeInput{FunctionName: aws.String("{{$.TypeNameOrginalCase}}{{.FuncName}}") {{if or .ReceiverName .InputParamType}}, Payload: jsonParam {{end}}})
	if _err != nil {
		return {{if .OptionalReturnType}} *new({{.OptionalReturnType}}), {{end}} _err
	}

    {{if .OptionalReturnType}}
	{{if .IsReturnTypeNobject}} result := new({{.OptionalReturnTypeUpper}}Stub)
	{{else}} result := new({{.OptionalReturnType}})
	{{end}}
	_err = json.Unmarshal(out.Payload, result)
	if _err != nil {
		return *new({{.OptionalReturnType}}), err
	}{{end}}
	
	return {{if .OptionalReturnType}}{{if .IsReturnTypeNobject}}New{{.OptionalReturnTypeUpper}}(result.GetId()),{{else}}*result,{{end}}{{end}} _err
} {{end}}

{{end}} 
