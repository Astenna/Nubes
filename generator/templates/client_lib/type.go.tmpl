package {{.PackageName}}
{{if or .MemberFunctions .FieldDefinitions}}
import (
    "errors"
	"encoding/json"
	"github.com/aws/aws-sdk-go/aws"
	"github.com/aws/aws-sdk-go/service/lambda"
	"github.com/Astenna/Nubes/lib"
){{end}}

type {{.TypeNameUpper}} struct {
	id string 
	{{if eq .NobjectImplementation ""}}{{range .FieldDefinitions}}
    	{{if .IsReference}} {{.FieldNameUpper}} lib.Reference[{{.FieldType}}] 
		{{else}} {{.FieldNameUpper}} {{.FieldType}} {{end}} 
	{{end}} {{end}}
}


{{if .NobjectImplementation}} // ALL THE CODE BELOW IS GENERATED ONLY FOR NOBJECTS TYPES
{{.NobjectImplementation}} 

// CONSTRUCTOR

func New{{.TypeNameUpper}}(id string) {{.TypeNameUpper}} {
	newInstance := new({{.TypeNameUpper}})
	newInstance.id = id
	return *newInstance
} 

// GETTERS AND SETTERS

{{range .FieldDefinitions}}
func (s {{$.TypeNameUpper}}) Get{{.FieldNameUpper}}() ({{.FieldType}}, error) {
	if s.id == "" {
		return *new({{.FieldType}}), errors.New("id of the type not set, use New{{$.TypeNameUpper}} constructor to create new instance of the type")
	}

	jsonParam, err := json.Marshal(s.id)
	if err != nil {
		return *new({{.FieldType}}), err
	}

	out, _err := LambdaClient.Invoke(&lambda.InvokeInput{FunctionName: aws.String("Get{{$.TypeNameUpper}}"), Payload: jsonParam})
	if _err != nil {
		return *new({{.FieldType}}), _err
	}

	result := new({{$.TypeNameUpper}}Stub)
	err = json.Unmarshal(out.Payload, result)
	if err != nil {
		return *new({{.FieldType}}), err
	}

	{{if .IsReference}}
	var referenceResult = New{{.FieldType}}(result.{{.FieldNameUpper}}.Id)
	return referenceResult, err
	{{else}}
	return result.{{.FieldNameUpper}}, err
	{{end}}
}
func (s {{$.TypeNameUpper}}) Set{{.FieldNameUpper}}(newValue {{if .IsReference}}string{{else}}{{.FieldType}}{{end}}) error {
	if s.id == "" {
		return errors.New("id of the type not set, use New{{$.TypeNameUpper}} constructor to create new instance of the type")
	}
	
	jsonParam, err := json.Marshal(aws.JSONValue{"{{.FieldNameUpper}}": newValue, "Id": s.id})
	if err != nil {
		return err
	}

	_, _err := LambdaClient.Invoke(&lambda.InvokeInput{FunctionName: aws.String("Update{{$.TypeNameUpper}}"), Payload: jsonParam})
	return _err
} 
{{end}}


// METHODS

{{range .MemberFunctions}}
func ({{.ReceiverName}} {{$.TypeNameUpper}}) {{.FuncName}}({{if .InputParamType}}input {{.InputParamType}}{{end}}) {{if .OptionalReturnType}} ({{.OptionalReturnType}}, error) {{else}} error {{end}} {
	{{if.ReceiverName}} if {{.ReceiverName}}.id == "" {
		return {{if .OptionalReturnType}} *new({{.OptionalReturnType}}), {{end}} errors.New("Id of the type not set, use New{{$.TypeNameUpper}} constructor to create new instance of the type")
	}{{end}}
	
	{{if or .ReceiverName .InputParamType}}params := new(lib.HandlerParameters) {{end}}
    {{if .ReceiverName}} params.Id = {{.ReceiverName}}.id {{end}}
    {{if .InputParamType}} params.Parameter = input {{end}}

	{{if or .ReceiverName .InputParamType}} jsonParam, err := json.Marshal(params)
	if err != nil {
		return {{if .OptionalReturnType}} *new({{.OptionalReturnType}}), {{end}} err
	} {{end}}

	{{if .OptionalReturnType}}out{{else}}_{{end}}, _err := LambdaClient.Invoke(&lambda.InvokeInput{FunctionName: aws.String("{{.FuncName}}{{$.TypeNameUpper}}") {{if or .ReceiverName .InputParamType}}, Payload: jsonParam {{end}}})
	if _err != nil {
		return {{if .OptionalReturnType}} *new({{.OptionalReturnType}}), {{end}} _err
	}

    {{if .OptionalReturnType}}
    result := new({{.OptionalReturnType}})
	_err = json.Unmarshal(out.Payload, result)
	if _err != nil {
		return *new({{.OptionalReturnType}}), err
	}{{end}}
	
	return {{if .OptionalReturnType}}*result,{{end}} _err
} {{end}}

{{end}} 
